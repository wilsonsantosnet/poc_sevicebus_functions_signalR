{"ast":null,"code":"import _objectSpread from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\objectSpread2.js\";\nimport _slicedToArray from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _asyncToGenerator from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\n\nexport var ServerSentEventsTransport = /*#__PURE__*/function () {\n  function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, options) {\n    _classCallCheck(this, ServerSentEventsTransport);\n\n    this._httpClient = httpClient;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  _createClass(ServerSentEventsTransport, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, transferFormat) {\n        var _this = this;\n\n        var token;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                Arg.isRequired(url, \"url\");\n                Arg.isRequired(transferFormat, \"transferFormat\");\n                Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n                this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\"); // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\n\n\n                this._url = url;\n\n                if (!this._accessTokenFactory) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 8;\n                return this._accessTokenFactory();\n\n              case 8:\n                token = _context.sent;\n\n                if (token) {\n                  url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(token));\n                }\n\n              case 10:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var opened = false;\n\n                  if (transferFormat !== TransferFormat.Text) {\n                    reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n                    return;\n                  }\n\n                  var eventSource;\n\n                  if (Platform.isBrowser || Platform.isWebWorker) {\n                    eventSource = new _this._options.EventSource(url, {\n                      withCredentials: _this._options.withCredentials\n                    });\n                  } else {\n                    // Non-browser passes cookies via the dictionary\n                    var cookies = _this._httpClient.getCookieString(url);\n\n                    var headers = {};\n                    headers.Cookie = cookies;\n\n                    var _getUserAgentHeader = getUserAgentHeader(),\n                        _getUserAgentHeader2 = _slicedToArray(_getUserAgentHeader, 2),\n                        name = _getUserAgentHeader2[0],\n                        value = _getUserAgentHeader2[1];\n\n                    headers[name] = value;\n                    eventSource = new _this._options.EventSource(url, {\n                      withCredentials: _this._options.withCredentials,\n                      headers: _objectSpread(_objectSpread({}, headers), _this._options.headers)\n                    });\n                  }\n\n                  try {\n                    eventSource.onmessage = function (e) {\n                      if (_this.onreceive) {\n                        try {\n                          _this._logger.log(LogLevel.Trace, \"(SSE transport) data received. \".concat(getDataDetail(e.data, _this._options.logMessageContent), \".\"));\n\n                          _this.onreceive(e.data);\n                        } catch (error) {\n                          _this._close(error);\n\n                          return;\n                        }\n                      }\n                    }; // @ts-ignore: not using event on purpose\n\n\n                    // @ts-ignore: not using event on purpose\n                    eventSource.onerror = function (e) {\n                      // EventSource doesn't give any useful information about server side closes.\n                      if (opened) {\n                        _this._close();\n                      } else {\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n                      }\n                    };\n\n                    eventSource.onopen = function () {\n                      _this._logger.log(LogLevel.Information, \"SSE connected to \".concat(_this._url));\n\n                      _this._eventSource = eventSource;\n                      opened = true;\n                      resolve();\n                    };\n                  } catch (e) {\n                    reject(e);\n                    return;\n                  }\n                }));\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._eventSource) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", Promise.reject(new Error(\"Cannot send until the transport is connected\")));\n\n              case 2:\n                return _context2.abrupt(\"return\", sendMessage(this._logger, \"SSE\", this._httpClient, this._url, this._accessTokenFactory, data, this._options));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._close();\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"_close\",\n    value: function _close(e) {\n      if (this._eventSource) {\n        this._eventSource.close();\n\n        this._eventSource = undefined;\n\n        if (this.onclose) {\n          this.onclose(e);\n        }\n      }\n    }\n  }]);\n\n  return ServerSentEventsTransport;\n}(); //# sourceMappingURL=ServerSentEventsTransport.js.map","map":null,"metadata":{},"sourceType":"module"}