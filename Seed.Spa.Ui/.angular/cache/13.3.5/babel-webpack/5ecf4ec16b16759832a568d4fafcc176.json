{"ast":null,"code":"import _objectSpread from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\objectSpread2.js\";\nimport _asyncToGenerator from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _inherits from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _regeneratorRuntime from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { Platform, getGlobalThis } from \"./Utils\";\nexport var FetchHttpClient = /*#__PURE__*/function (_HttpClient) {\n  _inherits(FetchHttpClient, _HttpClient);\n\n  var _super = _createSuper(FetchHttpClient);\n\n  function FetchHttpClient(logger) {\n    var _this;\n\n    _classCallCheck(this, FetchHttpClient);\n\n    _this = _super.call(this);\n    _this._logger = logger;\n\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n\n      _this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      _this._fetchType = requireFunc(\"node-fetch\"); // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n\n      _this._fetchType = requireFunc(\"fetch-cookie\")(_this._fetchType, _this._jar);\n    } else {\n      _this._fetchType = fetch.bind(getGlobalThis());\n    }\n\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var _requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n\n\n      _this._abortControllerType = _requireFunc(\"abort-controller\");\n    } else {\n      _this._abortControllerType = AbortController;\n    }\n\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  _createClass(FetchHttpClient, [{\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request) {\n        var _this2 = this;\n\n        var abortController, error, timeoutId, msTimeout, response, errorMessage, content, payload;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(request.abortSignal && request.abortSignal.aborted)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new AbortError();\n\n              case 2:\n                if (request.method) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error(\"No method defined.\");\n\n              case 4:\n                if (request.url) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error(\"No url defined.\");\n\n              case 6:\n                abortController = new this._abortControllerType();\n\n                // Hook our abortSignal into the abort controller\n                if (request.abortSignal) {\n                  request.abortSignal.onabort = function () {\n                    abortController.abort();\n                    error = new AbortError();\n                  };\n                } // If a timeout has been passed in, setup a timeout to call abort\n                // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n\n\n                timeoutId = null;\n\n                if (request.timeout) {\n                  msTimeout = request.timeout;\n                  timeoutId = setTimeout(function () {\n                    abortController.abort();\n\n                    _this2._logger.log(LogLevel.Warning, \"Timeout from HTTP request.\");\n\n                    error = new TimeoutError();\n                  }, msTimeout);\n                }\n\n                _context.prev = 10;\n                _context.next = 13;\n                return this._fetchType(request.url, {\n                  body: request.content,\n                  cache: \"no-cache\",\n                  credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n                  headers: _objectSpread({\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\n                    \"X-Requested-With\": \"XMLHttpRequest\"\n                  }, request.headers),\n                  method: request.method,\n                  mode: \"cors\",\n                  redirect: \"follow\",\n                  signal: abortController.signal\n                });\n\n              case 13:\n                response = _context.sent;\n                _context.next = 22;\n                break;\n\n              case 16:\n                _context.prev = 16;\n                _context.t0 = _context[\"catch\"](10);\n\n                if (!error) {\n                  _context.next = 20;\n                  break;\n                }\n\n                throw error;\n\n              case 20:\n                this._logger.log(LogLevel.Warning, \"Error from HTTP request. \".concat(_context.t0, \".\"));\n\n                throw _context.t0;\n\n              case 22:\n                _context.prev = 22;\n\n                if (timeoutId) {\n                  clearTimeout(timeoutId);\n                }\n\n                if (request.abortSignal) {\n                  request.abortSignal.onabort = null;\n                }\n\n                return _context.finish(22);\n\n              case 26:\n                if (response.ok) {\n                  _context.next = 31;\n                  break;\n                }\n\n                _context.next = 29;\n                return deserializeContent(response, \"text\");\n\n              case 29:\n                errorMessage = _context.sent;\n                throw new HttpError(errorMessage || response.statusText, response.status);\n\n              case 31:\n                content = deserializeContent(response, request.responseType);\n                _context.next = 34;\n                return content;\n\n              case 34:\n                payload = _context.sent;\n                return _context.abrupt(\"return\", new HttpResponse(response.status, response.statusText, payload));\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 16, 22, 26]]);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"getCookieString\",\n    value: function getCookieString(url) {\n      var cookies = \"\";\n\n      if (Platform.isNode && this._jar) {\n        // @ts-ignore: unused variable\n        this._jar.getCookies(url, function (e, c) {\n          return cookies = c.join(\"; \");\n        });\n      }\n\n      return cookies;\n    }\n  }]);\n\n  return FetchHttpClient;\n}(HttpClient);\n\nfunction deserializeContent(response, responseType) {\n  var content;\n\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n\n    case \"text\":\n      content = response.text();\n      break;\n\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(\"\".concat(responseType, \" is not supported.\"));\n\n    default:\n      content = response.text();\n      break;\n  }\n\n  return content;\n} //# sourceMappingURL=FetchHttpClient.js.map","map":null,"metadata":{},"sourceType":"module"}