{"ast":null,"code":"import _defineProperty from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _objectSpread from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\objectSpread2.js\";\nimport _slicedToArray from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _asyncToGenerator from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AbortController } from \"./AbortController\";\nimport { HttpError, TimeoutError } from \"./Errors\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\"; // Not exported from 'index', this type is internal.\n\n/** @private */\n\nexport var LongPollingTransport = /*#__PURE__*/function () {\n  function LongPollingTransport(httpClient, accessTokenFactory, logger, options) {\n    _classCallCheck(this, LongPollingTransport);\n\n    this._httpClient = httpClient;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logger = logger;\n    this._pollAbort = new AbortController();\n    this._options = options;\n    this._running = false;\n    this.onreceive = null;\n    this.onclose = null;\n  } // This is an internal type, not exported from 'index' so this is really just internal.\n\n\n  _createClass(LongPollingTransport, [{\n    key: \"pollAborted\",\n    get: function get() {\n      return this._pollAbort.aborted;\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, transferFormat) {\n        var _getUserAgentHeader, _getUserAgentHeader2, name, value, headers, pollOptions, token, pollUrl, response;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                Arg.isRequired(url, \"url\");\n                Arg.isRequired(transferFormat, \"transferFormat\");\n                Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n                this._url = url;\n\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\"); // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\n\n\n                if (!(transferFormat === TransferFormat.Binary && typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n\n              case 7:\n                _getUserAgentHeader = getUserAgentHeader(), _getUserAgentHeader2 = _slicedToArray(_getUserAgentHeader, 2), name = _getUserAgentHeader2[0], value = _getUserAgentHeader2[1];\n                headers = _objectSpread(_defineProperty({}, name, value), this._options.headers);\n                pollOptions = {\n                  abortSignal: this._pollAbort.signal,\n                  headers: headers,\n                  timeout: 100000,\n                  withCredentials: this._options.withCredentials\n                };\n\n                if (transferFormat === TransferFormat.Binary) {\n                  pollOptions.responseType = \"arraybuffer\";\n                }\n\n                _context.next = 13;\n                return this._getAccessToken();\n\n              case 13:\n                token = _context.sent;\n\n                this._updateHeaderToken(pollOptions, token); // Make initial long polling request\n                // Server uses first long polling request to finish initializing connection and it returns without data\n\n\n                pollUrl = \"\".concat(url, \"&_=\").concat(Date.now());\n\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) polling: \".concat(pollUrl, \".\"));\n\n                _context.next = 19;\n                return this._httpClient.get(pollUrl, pollOptions);\n\n              case 19:\n                response = _context.sent;\n\n                if (response.statusCode !== 200) {\n                  this._logger.log(LogLevel.Error, \"(LongPolling transport) Unexpected response code: \".concat(response.statusCode, \".\")); // Mark running as false so that the poll immediately ends and runs the close logic\n\n\n                  this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\n                  this._running = false;\n                } else {\n                  this._running = true;\n                }\n\n                this._receiving = this._poll(this._url, pollOptions);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"_getAccessToken\",\n    value: function () {\n      var _getAccessToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._accessTokenFactory) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this._accessTokenFactory();\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n                return _context2.abrupt(\"return\", null);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getAccessToken() {\n        return _getAccessToken2.apply(this, arguments);\n      }\n\n      return _getAccessToken;\n    }()\n  }, {\n    key: \"_updateHeaderToken\",\n    value: function _updateHeaderToken(request, token) {\n      if (!request.headers) {\n        request.headers = {};\n      }\n\n      if (token) {\n        request.headers[HeaderNames.Authorization] = \"Bearer \".concat(token);\n        return;\n      }\n\n      if (request.headers[HeaderNames.Authorization]) {\n        delete request.headers[HeaderNames.Authorization];\n      }\n    }\n  }, {\n    key: \"_poll\",\n    value: function () {\n      var _poll2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url, pollOptions) {\n        var token, pollUrl, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n\n              case 1:\n                if (!this._running) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _context3.next = 4;\n                return this._getAccessToken();\n\n              case 4:\n                token = _context3.sent;\n\n                this._updateHeaderToken(pollOptions, token);\n\n                _context3.prev = 6;\n                pollUrl = \"\".concat(url, \"&_=\").concat(Date.now());\n\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) polling: \".concat(pollUrl, \".\"));\n\n                _context3.next = 11;\n                return this._httpClient.get(pollUrl, pollOptions);\n\n              case 11:\n                response = _context3.sent;\n\n                if (response.statusCode === 204) {\n                  this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\n\n                  this._running = false;\n                } else if (response.statusCode !== 200) {\n                  this._logger.log(LogLevel.Error, \"(LongPolling transport) Unexpected response code: \".concat(response.statusCode, \".\")); // Unexpected status code\n\n\n                  this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\n                  this._running = false;\n                } else {\n                  // Process the response\n                  if (response.content) {\n                    this._logger.log(LogLevel.Trace, \"(LongPolling transport) data received. \".concat(getDataDetail(response.content, this._options.logMessageContent), \".\"));\n\n                    if (this.onreceive) {\n                      this.onreceive(response.content);\n                    }\n                  } else {\n                    // This is another way timeout manifest.\n                    this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n                  }\n                }\n\n                _context3.next = 18;\n                break;\n\n              case 15:\n                _context3.prev = 15;\n                _context3.t0 = _context3[\"catch\"](6);\n\n                if (!this._running) {\n                  // Log but disregard errors that occur after stopping\n                  this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll errored after shutdown: \".concat(_context3.t0.message));\n                } else {\n                  if (_context3.t0 instanceof TimeoutError) {\n                    // Ignore timeouts and reissue the poll.\n                    this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n                  } else {\n                    // Close the connection with the error as the result.\n                    this._closeError = _context3.t0;\n                    this._running = false;\n                  }\n                }\n\n              case 18:\n                _context3.next = 1;\n                break;\n\n              case 20:\n                _context3.prev = 20;\n\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\"); // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\n                // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\n\n\n                if (!this.pollAborted) {\n                  this._raiseOnClose();\n                }\n\n                return _context3.finish(20);\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0,, 20, 24], [6, 15]]);\n      }));\n\n      function _poll(_x3, _x4) {\n        return _poll2.apply(this, arguments);\n      }\n\n      return _poll;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this._running) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.reject(new Error(\"Cannot send until the transport is connected\")));\n\n              case 2:\n                return _context4.abrupt(\"return\", sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url, this._accessTokenFactory, data, this._options));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function send(_x5) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var headers, _getUserAgentHeader3, _getUserAgentHeader4, name, value, deleteOptions, token;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\"); // Tell receiving loop to stop, abort any current request, and then wait for it to finish\n\n\n                this._running = false;\n\n                this._pollAbort.abort();\n\n                _context5.prev = 3;\n                _context5.next = 6;\n                return this._receiving;\n\n              case 6:\n                // Send DELETE to clean up long polling on the server\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) sending DELETE request to \".concat(this._url, \".\"));\n\n                headers = {};\n                _getUserAgentHeader3 = getUserAgentHeader(), _getUserAgentHeader4 = _slicedToArray(_getUserAgentHeader3, 2), name = _getUserAgentHeader4[0], value = _getUserAgentHeader4[1];\n                headers[name] = value;\n                deleteOptions = {\n                  headers: _objectSpread(_objectSpread({}, headers), this._options.headers),\n                  timeout: this._options.timeout,\n                  withCredentials: this._options.withCredentials\n                };\n                _context5.next = 13;\n                return this._getAccessToken();\n\n              case 13:\n                token = _context5.sent;\n\n                this._updateHeaderToken(deleteOptions, token);\n\n                _context5.next = 17;\n                return this._httpClient.delete(this._url, deleteOptions);\n\n              case 17:\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\n\n              case 18:\n                _context5.prev = 18;\n\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\"); // Raise close event here instead of in polling\n                // It needs to happen after the DELETE request is sent\n\n\n                this._raiseOnClose();\n\n                return _context5.finish(18);\n\n              case 22:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[3,, 18, 22]]);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"_raiseOnClose\",\n    value: function _raiseOnClose() {\n      if (this.onclose) {\n        var logMessage = \"(LongPolling transport) Firing onclose event.\";\n\n        if (this._closeError) {\n          logMessage += \" Error: \" + this._closeError;\n        }\n\n        this._logger.log(LogLevel.Trace, logMessage);\n\n        this.onclose(this._closeError);\n      }\n    }\n  }]);\n\n  return LongPollingTransport;\n}(); //# sourceMappingURL=LongPollingTransport.js.map","map":null,"metadata":{},"sourceType":"module"}