{"ast":null,"code":"import _objectSpread from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\objectSpread2.js\";\nimport _slicedToArray from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _asyncToGenerator from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\n/** @private */\n\nexport var WebSocketTransport = /*#__PURE__*/function () {\n  function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    _classCallCheck(this, WebSocketTransport);\n\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n\n  _createClass(WebSocketTransport, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, transferFormat) {\n        var _this = this;\n\n        var token;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                Arg.isRequired(url, \"url\");\n                Arg.isRequired(transferFormat, \"transferFormat\");\n                Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n                this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n\n                if (!this._accessTokenFactory) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 7;\n                return this._accessTokenFactory();\n\n              case 7:\n                token = _context.sent;\n\n                if (token) {\n                  url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(token));\n                }\n\n              case 9:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  url = url.replace(/^http/, \"ws\");\n                  var webSocket;\n\n                  var cookies = _this._httpClient.getCookieString(url);\n\n                  var opened = false;\n\n                  if (Platform.isNode) {\n                    var headers = {};\n\n                    var _getUserAgentHeader = getUserAgentHeader(),\n                        _getUserAgentHeader2 = _slicedToArray(_getUserAgentHeader, 2),\n                        name = _getUserAgentHeader2[0],\n                        value = _getUserAgentHeader2[1];\n\n                    headers[name] = value;\n\n                    if (cookies) {\n                      headers[HeaderNames.Cookie] = \"\".concat(cookies);\n                    } // Only pass headers when in non-browser environments\n\n\n                    // Only pass headers when in non-browser environments\n                    webSocket = new _this._webSocketConstructor(url, undefined, {\n                      headers: _objectSpread(_objectSpread({}, headers), _this._headers)\n                    });\n                  }\n\n                  if (!webSocket) {\n                    // Chrome is not happy with passing 'undefined' as protocol\n                    webSocket = new _this._webSocketConstructor(url);\n                  }\n\n                  if (transferFormat === TransferFormat.Binary) {\n                    webSocket.binaryType = \"arraybuffer\";\n                  }\n\n                  webSocket.onopen = function (_event) {\n                    _this._logger.log(LogLevel.Information, \"WebSocket connected to \".concat(url, \".\"));\n\n                    _this._webSocket = webSocket;\n                    opened = true;\n                    resolve();\n                  };\n\n                  webSocket.onerror = function (event) {\n                    var error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                      error = event.error;\n                    } else {\n                      error = \"There was an error with the transport\";\n                    }\n\n                    _this._logger.log(LogLevel.Information, \"(WebSockets transport) \".concat(error, \".\"));\n                  };\n\n                  webSocket.onmessage = function (message) {\n                    _this._logger.log(LogLevel.Trace, \"(WebSockets transport) data received. \".concat(getDataDetail(message.data, _this._logMessageContent), \".\"));\n\n                    if (_this.onreceive) {\n                      try {\n                        _this.onreceive(message.data);\n                      } catch (error) {\n                        _this._close(error);\n\n                        return;\n                      }\n                    }\n                  };\n\n                  webSocket.onclose = function (event) {\n                    // Don't call close handler if connection was never established\n                    // We'll reject the connect call instead\n                    if (opened) {\n                      _this._close(event);\n                    } else {\n                      var error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n                      // ErrorEvent is a browser only type we need to check if the type exists before using it\n                      if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                        error = event.error;\n                      } else {\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n                      }\n\n                      reject(new Error(error));\n                    }\n                  };\n                }));\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) sending data. \".concat(getDataDetail(data, this._logMessageContent), \".\"));\n\n        this._webSocket.send(data);\n\n        return Promise.resolve();\n      }\n\n      return Promise.reject(\"WebSocket is not in the OPEN state\");\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._webSocket) {\n        // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n        // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n        this._close(undefined);\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"_close\",\n    value: function _close(event) {\n      // webSocket will be null if the transport did not start successfully\n      if (this._webSocket) {\n        // Clear websocket handlers because we are considering the socket closed now\n        this._webSocket.onclose = function () {};\n\n        this._webSocket.onmessage = function () {};\n\n        this._webSocket.onerror = function () {};\n\n        this._webSocket.close();\n\n        this._webSocket = undefined;\n      }\n\n      this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n\n      if (this.onclose) {\n        if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n          this.onclose(new Error(\"WebSocket closed with status code: \".concat(event.code, \" (\").concat(event.reason || \"no reason given\", \").\")));\n        } else if (event instanceof Error) {\n          this.onclose(event);\n        } else {\n          this.onclose();\n        }\n      }\n    }\n  }, {\n    key: \"_isCloseEvent\",\n    value: function _isCloseEvent(event) {\n      return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n    }\n  }]);\n\n  return WebSocketTransport;\n}(); //# sourceMappingURL=WebSocketTransport.js.map","map":null,"metadata":{},"sourceType":"module"}