{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _asyncToGenerator from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\projetos\\\\gerador-project-all-solution\\\\Seed.Spa.Ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Subject } from \"./Subject\";\nimport { Arg, getErrorString, Platform } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\n\nexport var HubConnectionState = /*#__PURE__*/(function () {\n  (function (HubConnectionState) {\n    /** The hub connection is disconnected. */\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n    /** The hub connection is connecting. */\n\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\n    /** The hub connection is connected. */\n\n    HubConnectionState[\"Connected\"] = \"Connected\";\n    /** The hub connection is disconnecting. */\n\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n    /** The hub connection is reconnecting. */\n\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n  })(HubConnectionState || (HubConnectionState = {}));\n\n  return HubConnectionState;\n})();\n\n/** Represents a connection to a SignalR Hub. */\nexport var HubConnection = /*#__PURE__*/function () {\n  function HubConnection(connection, logger, protocol, reconnectPolicy) {\n    var _this = this;\n\n    _classCallCheck(this, HubConnection);\n\n    this._nextKeepAlive = 0;\n\n    this._freezeEventListener = function () {\n      _this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n    };\n\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this._logger = logger;\n    this._protocol = protocol;\n    this.connection = connection;\n    this._reconnectPolicy = reconnectPolicy;\n    this._handshakeProtocol = new HandshakeProtocol();\n\n    this.connection.onreceive = function (data) {\n      return _this._processIncomingData(data);\n    };\n\n    this.connection.onclose = function (error) {\n      return _this._connectionClosed(error);\n    };\n\n    this._callbacks = {};\n    this._methods = {};\n    this._closedCallbacks = [];\n    this._reconnectingCallbacks = [];\n    this._reconnectedCallbacks = [];\n    this._invocationId = 0;\n    this._receivedHandshakeResponse = false;\n    this._connectionState = HubConnectionState.Disconnected;\n    this._connectionStarted = false;\n    this._cachedPingMessage = this._protocol.writeMessage({\n      type: MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n\n\n  _createClass(HubConnection, [{\n    key: \"state\",\n    get:\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    function get() {\n      return this._connectionState;\n    }\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\n\n  }, {\n    key: \"connectionId\",\n    get: function get() {\n      return this.connection ? this.connection.connectionId || null : null;\n    }\n    /** Indicates the url of the {@link HubConnection} to the server. */\n\n  }, {\n    key: \"baseUrl\",\n    get: function get() {\n      return this.connection.baseUrl || \"\";\n    }\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\n    ,\n    set: function set(url) {\n      if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\n        throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n      }\n\n      if (!url) {\n        throw new Error(\"The HubConnection url must be a valid url.\");\n      }\n\n      this.connection.baseUrl = url;\n    }\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._startPromise = this._startWithStateTransitions();\n      return this._startPromise;\n    }\n  }, {\n    key: \"_startWithStateTransitions\",\n    value: function () {\n      var _startWithStateTransitions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._connectionState !== HubConnectionState.Disconnected)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\")));\n\n              case 2:\n                this._connectionState = HubConnectionState.Connecting;\n\n                this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n\n                _context.prev = 4;\n                _context.next = 7;\n                return this._startInternal();\n\n              case 7:\n                if (Platform.isBrowser) {\n                  // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\n                  window.document.addEventListener(\"freeze\", this._freezeEventListener);\n                }\n\n                this._connectionState = HubConnectionState.Connected;\n                this._connectionStarted = true;\n\n                this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\n\n                _context.next = 18;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](4);\n                this._connectionState = HubConnectionState.Disconnected;\n\n                this._logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\".concat(_context.t0, \"'.\"));\n\n                return _context.abrupt(\"return\", Promise.reject(_context.t0));\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 13]]);\n      }));\n\n      function _startWithStateTransitions() {\n        return _startWithStateTransitions2.apply(this, arguments);\n      }\n\n      return _startWithStateTransitions;\n    }()\n  }, {\n    key: \"_startInternal\",\n    value: function () {\n      var _startInternal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var handshakePromise, handshakeRequest;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._stopDuringStartError = undefined;\n                this._receivedHandshakeResponse = false; // Set up the promise before any connection is (re)started otherwise it could race with received messages\n\n                handshakePromise = new Promise(function (resolve, reject) {\n                  _this2._handshakeResolver = resolve;\n                  _this2._handshakeRejecter = reject;\n                });\n                _context2.next = 5;\n                return this.connection.start(this._protocol.transferFormat);\n\n              case 5:\n                _context2.prev = 5;\n                handshakeRequest = {\n                  protocol: this._protocol.name,\n                  version: this._protocol.version\n                };\n\n                this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\n\n                _context2.next = 10;\n                return this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\n\n              case 10:\n                this._logger.log(LogLevel.Information, \"Using HubProtocol '\".concat(this._protocol.name, \"'.\")); // defensively cleanup timeout in case we receive a message from the server before we finish start\n\n\n                this._cleanupTimeout();\n\n                this._resetTimeoutPeriod();\n\n                this._resetKeepAliveInterval();\n\n                _context2.next = 16;\n                return handshakePromise;\n\n              case 16:\n                if (!this._stopDuringStartError) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                throw this._stopDuringStartError;\n\n              case 18:\n                _context2.next = 28;\n                break;\n\n              case 20:\n                _context2.prev = 20;\n                _context2.t0 = _context2[\"catch\"](5);\n\n                this._logger.log(LogLevel.Debug, \"Hub handshake failed with error '\".concat(_context2.t0, \"' during start(). Stopping HubConnection.\"));\n\n                this._cleanupTimeout();\n\n                this._cleanupPingTimer(); // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n                // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n\n\n                _context2.next = 27;\n                return this.connection.stop(_context2.t0);\n\n              case 27:\n                throw _context2.t0;\n\n              case 28:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 20]]);\n      }));\n\n      function _startInternal() {\n        return _startInternal2.apply(this, arguments);\n      }\n\n      return _startInternal;\n    }()\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var startPromise;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // Capture the start promise before the connection might be restarted in an onclose callback.\n                startPromise = this._startPromise;\n                this._stopPromise = this._stopInternal();\n                _context3.next = 4;\n                return this._stopPromise;\n\n              case 4:\n                _context3.prev = 4;\n                _context3.next = 7;\n                return startPromise;\n\n              case 7:\n                _context3.next = 11;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](4);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 9]]);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"_stopInternal\",\n    value: function _stopInternal(error) {\n      if (this._connectionState === HubConnectionState.Disconnected) {\n        this._logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\".concat(error, \") ignored because it is already in the disconnected state.\"));\n\n        return Promise.resolve();\n      }\n\n      if (this._connectionState === HubConnectionState.Disconnecting) {\n        this._logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnecting state.\"));\n\n        return this._stopPromise;\n      }\n\n      this._connectionState = HubConnectionState.Disconnecting;\n\n      this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n\n      if (this._reconnectDelayHandle) {\n        // We're in a reconnect delay which means the underlying connection is currently already stopped.\n        // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n        // fire the onclose callbacks.\n        this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n\n        clearTimeout(this._reconnectDelayHandle);\n        this._reconnectDelayHandle = undefined;\n\n        this._completeClose();\n\n        return Promise.resolve();\n      }\n\n      this._cleanupTimeout();\n\n      this._cleanupPingTimer();\n\n      this._stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\"); // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n      // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n      // to the disconnected state if need be before HttpConnection.stop() completes.\n\n      return this.connection.stop(error);\n    }\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\n\n  }, {\n    key: \"stream\",\n    value: function stream(methodName) {\n      var _this3 = this;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var _this$_replaceStreami = this._replaceStreamingParams(args),\n          _this$_replaceStreami2 = _slicedToArray(_this$_replaceStreami, 2),\n          streams = _this$_replaceStreami2[0],\n          streamIds = _this$_replaceStreami2[1];\n\n      var invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds); // eslint-disable-next-line prefer-const\n\n\n      var promiseQueue;\n      var subject = new Subject();\n\n      subject.cancelCallback = function () {\n        var cancelInvocation = _this3._createCancelInvocation(invocationDescriptor.invocationId);\n\n        delete _this3._callbacks[invocationDescriptor.invocationId];\n        return promiseQueue.then(function () {\n          return _this3._sendWithProtocol(cancelInvocation);\n        });\n      };\n\n      this._callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          subject.error(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === MessageType.Completion) {\n            if (invocationEvent.error) {\n              subject.error(new Error(invocationEvent.error));\n            } else {\n              subject.complete();\n            }\n          } else {\n            subject.next(invocationEvent.item);\n          }\n        }\n      };\n\n      promiseQueue = this._sendWithProtocol(invocationDescriptor).catch(function (e) {\n        subject.error(e);\n        delete _this3._callbacks[invocationDescriptor.invocationId];\n      });\n\n      this._launchStreams(streams, promiseQueue);\n\n      return subject;\n    }\n  }, {\n    key: \"_sendMessage\",\n    value: function _sendMessage(message) {\n      this._resetKeepAliveInterval();\n\n      return this.connection.send(message);\n    }\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\n\n  }, {\n    key: \"_sendWithProtocol\",\n    value: function _sendWithProtocol(message) {\n      return this._sendMessage(this._protocol.writeMessage(message));\n    }\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(methodName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var _this$_replaceStreami3 = this._replaceStreamingParams(args),\n          _this$_replaceStreami4 = _slicedToArray(_this$_replaceStreami3, 2),\n          streams = _this$_replaceStreami4[0],\n          streamIds = _this$_replaceStreami4[1];\n\n      var sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\n\n      this._launchStreams(streams, sendPromise);\n\n      return sendPromise;\n    }\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\n\n  }, {\n    key: \"invoke\",\n    value: function invoke(methodName) {\n      var _this4 = this;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var _this$_replaceStreami5 = this._replaceStreamingParams(args),\n          _this$_replaceStreami6 = _slicedToArray(_this$_replaceStreami5, 2),\n          streams = _this$_replaceStreami6[0],\n          streamIds = _this$_replaceStreami6[1];\n\n      var invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\n\n      var p = new Promise(function (resolve, reject) {\n        // invocationId will always have a value for a non-blocking invocation\n        _this4._callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n          if (error) {\n            reject(error);\n            return;\n          } else if (invocationEvent) {\n            // invocationEvent will not be null when an error is not passed to the callback\n            if (invocationEvent.type === MessageType.Completion) {\n              if (invocationEvent.error) {\n                reject(new Error(invocationEvent.error));\n              } else {\n                resolve(invocationEvent.result);\n              }\n            } else {\n              reject(new Error(\"Unexpected message type: \".concat(invocationEvent.type)));\n            }\n          }\n        };\n\n        var promiseQueue = _this4._sendWithProtocol(invocationDescriptor).catch(function (e) {\n          reject(e); // invocationId will always have a value for a non-blocking invocation\n\n          delete _this4._callbacks[invocationDescriptor.invocationId];\n        });\n\n        _this4._launchStreams(streams, promiseQueue);\n      });\n      return p;\n    }\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(methodName, newMethod) {\n      if (!methodName || !newMethod) {\n        return;\n      }\n\n      methodName = methodName.toLowerCase();\n\n      if (!this._methods[methodName]) {\n        this._methods[methodName] = [];\n      } // Preventing adding the same handler multiple times.\n\n\n      if (this._methods[methodName].indexOf(newMethod) !== -1) {\n        return;\n      }\n\n      this._methods[methodName].push(newMethod);\n    }\n  }, {\n    key: \"off\",\n    value: function off(methodName, method) {\n      if (!methodName) {\n        return;\n      }\n\n      methodName = methodName.toLowerCase();\n      var handlers = this._methods[methodName];\n\n      if (!handlers) {\n        return;\n      }\n\n      if (method) {\n        var removeIdx = handlers.indexOf(method);\n\n        if (removeIdx !== -1) {\n          handlers.splice(removeIdx, 1);\n\n          if (handlers.length === 0) {\n            delete this._methods[methodName];\n          }\n        }\n      } else {\n        delete this._methods[methodName];\n      }\n    }\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\n\n  }, {\n    key: \"onclose\",\n    value: function onclose(callback) {\n      if (callback) {\n        this._closedCallbacks.push(callback);\n      }\n    }\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\n\n  }, {\n    key: \"onreconnecting\",\n    value: function onreconnecting(callback) {\n      if (callback) {\n        this._reconnectingCallbacks.push(callback);\n      }\n    }\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\n\n  }, {\n    key: \"onreconnected\",\n    value: function onreconnected(callback) {\n      if (callback) {\n        this._reconnectedCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"_processIncomingData\",\n    value: function _processIncomingData(data) {\n      this._cleanupTimeout();\n\n      if (!this._receivedHandshakeResponse) {\n        data = this._processHandshakeResponse(data);\n        this._receivedHandshakeResponse = true;\n      } // Data may have all been read when processing handshake response\n\n\n      if (data) {\n        // Parse the messages\n        var messages = this._protocol.parseMessages(data, this._logger);\n\n        var _iterator = _createForOfIteratorHelper(messages),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var message = _step.value;\n\n            switch (message.type) {\n              case MessageType.Invocation:\n                this._invokeClientMethod(message);\n\n                break;\n\n              case MessageType.StreamItem:\n              case MessageType.Completion:\n                {\n                  var callback = this._callbacks[message.invocationId];\n\n                  if (callback) {\n                    if (message.type === MessageType.Completion) {\n                      delete this._callbacks[message.invocationId];\n                    }\n\n                    try {\n                      callback(message);\n                    } catch (e) {\n                      this._logger.log(LogLevel.Error, \"Stream callback threw error: \".concat(getErrorString(e)));\n                    }\n                  }\n\n                  break;\n                }\n\n              case MessageType.Ping:\n                // Don't care about pings\n                break;\n\n              case MessageType.Close:\n                {\n                  this._logger.log(LogLevel.Information, \"Close message received from server.\");\n\n                  var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n\n                  if (message.allowReconnect === true) {\n                    // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n                    // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this.connection.stop(error);\n                  } else {\n                    // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n                    this._stopPromise = this._stopInternal(error);\n                  }\n\n                  break;\n                }\n\n              default:\n                this._logger.log(LogLevel.Warning, \"Invalid message type: \".concat(message.type, \".\"));\n\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      this._resetTimeoutPeriod();\n    }\n  }, {\n    key: \"_processHandshakeResponse\",\n    value: function _processHandshakeResponse(data) {\n      var responseMessage;\n      var remainingData;\n\n      try {\n        var _this$_handshakeProto = this._handshakeProtocol.parseHandshakeResponse(data);\n\n        var _this$_handshakeProto2 = _slicedToArray(_this$_handshakeProto, 2);\n\n        remainingData = _this$_handshakeProto2[0];\n        responseMessage = _this$_handshakeProto2[1];\n      } catch (e) {\n        var message = \"Error parsing handshake response: \" + e;\n\n        this._logger.log(LogLevel.Error, message);\n\n        var error = new Error(message);\n\n        this._handshakeRejecter(error);\n\n        throw error;\n      }\n\n      if (responseMessage.error) {\n        var _message = \"Server returned handshake error: \" + responseMessage.error;\n\n        this._logger.log(LogLevel.Error, _message);\n\n        var _error = new Error(_message);\n\n        this._handshakeRejecter(_error);\n\n        throw _error;\n      } else {\n        this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\n      }\n\n      this._handshakeResolver();\n\n      return remainingData;\n    }\n  }, {\n    key: \"_resetKeepAliveInterval\",\n    value: function _resetKeepAliveInterval() {\n      if (this.connection.features.inherentKeepAlive) {\n        return;\n      } // Set the time we want the next keep alive to be sent\n      // Timer will be setup on next message receive\n\n\n      this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\n\n      this._cleanupPingTimer();\n    }\n  }, {\n    key: \"_resetTimeoutPeriod\",\n    value: function _resetTimeoutPeriod() {\n      var _this5 = this;\n\n      if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n        // Set the timeout timer\n        this._timeoutHandle = setTimeout(function () {\n          return _this5.serverTimeout();\n        }, this.serverTimeoutInMilliseconds); // Set keepAlive timer if there isn't one\n\n        if (this._pingServerHandle === undefined) {\n          var nextPing = this._nextKeepAlive - new Date().getTime();\n\n          if (nextPing < 0) {\n            nextPing = 0;\n          } // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\n\n\n          this._pingServerHandle = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    if (!(_this5._connectionState === HubConnectionState.Connected)) {\n                      _context4.next = 9;\n                      break;\n                    }\n\n                    _context4.prev = 1;\n                    _context4.next = 4;\n                    return _this5._sendMessage(_this5._cachedPingMessage);\n\n                  case 4:\n                    _context4.next = 9;\n                    break;\n\n                  case 6:\n                    _context4.prev = 6;\n                    _context4.t0 = _context4[\"catch\"](1);\n\n                    // We don't care about the error. It should be seen elsewhere in the client.\n                    // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n                    _this5._cleanupPingTimer();\n\n                  case 9:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[1, 6]]);\n          })), nextPing);\n        }\n      }\n    } // eslint-disable-next-line @typescript-eslint/naming-convention\n\n  }, {\n    key: \"serverTimeout\",\n    value: function serverTimeout() {\n      // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n      // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n    }\n  }, {\n    key: \"_invokeClientMethod\",\n    value: function _invokeClientMethod(invocationMessage) {\n      var _this6 = this;\n\n      var methods = this._methods[invocationMessage.target.toLowerCase()];\n\n      if (methods) {\n        try {\n          methods.forEach(function (m) {\n            return m.apply(_this6, invocationMessage.arguments);\n          });\n        } catch (e) {\n          this._logger.log(LogLevel.Error, \"A callback for the method \".concat(invocationMessage.target.toLowerCase(), \" threw error '\").concat(e, \"'.\"));\n        }\n\n        if (invocationMessage.invocationId) {\n          // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n          var message = \"Server requested a response, which is not supported in this version of the client.\";\n\n          this._logger.log(LogLevel.Error, message); // We don't want to wait on the stop itself.\n\n\n          this._stopPromise = this._stopInternal(new Error(message));\n        }\n      } else {\n        this._logger.log(LogLevel.Warning, \"No client method with the name '\".concat(invocationMessage.target, \"' found.\"));\n      }\n    }\n  }, {\n    key: \"_connectionClosed\",\n    value: function _connectionClosed(error) {\n      this._logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\".concat(error, \") called while in state \").concat(this._connectionState, \".\")); // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n\n\n      this._stopDuringStartError = this._stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\"); // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n      // If it has already completed, this should just noop.\n\n      if (this._handshakeResolver) {\n        this._handshakeResolver();\n      }\n\n      this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n\n      this._cleanupTimeout();\n\n      this._cleanupPingTimer();\n\n      if (this._connectionState === HubConnectionState.Disconnecting) {\n        this._completeClose(error);\n      } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._reconnect(error);\n      } else if (this._connectionState === HubConnectionState.Connected) {\n        this._completeClose(error);\n      } // If none of the above if conditions were true were called the HubConnection must be in either:\n      // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n      // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n      //    and potentially continue the reconnect() loop.\n      // 3. The Disconnected state in which case we're already done.\n\n    }\n  }, {\n    key: \"_completeClose\",\n    value: function _completeClose(error) {\n      var _this7 = this;\n\n      if (this._connectionStarted) {\n        this._connectionState = HubConnectionState.Disconnected;\n        this._connectionStarted = false;\n\n        if (Platform.isBrowser) {\n          window.document.removeEventListener(\"freeze\", this._freezeEventListener);\n        }\n\n        try {\n          this._closedCallbacks.forEach(function (c) {\n            return c.apply(_this7, [error]);\n          });\n        } catch (e) {\n          this._logger.log(LogLevel.Error, \"An onclose callback called with error '\".concat(error, \"' threw error '\").concat(e, \"'.\"));\n        }\n      }\n    }\n  }, {\n    key: \"_reconnect\",\n    value: function () {\n      var _reconnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(error) {\n        var _this8 = this;\n\n        var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                reconnectStartTime = Date.now();\n                previousReconnectAttempts = 0;\n                retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n\n                if (!(nextRetryDelay === null)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n\n                this._completeClose(error);\n\n                return _context5.abrupt(\"return\");\n\n              case 8:\n                this._connectionState = HubConnectionState.Reconnecting;\n\n                if (error) {\n                  this._logger.log(LogLevel.Information, \"Connection reconnecting because of error '\".concat(error, \"'.\"));\n                } else {\n                  this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\n                }\n\n                if (!(this._reconnectingCallbacks.length !== 0)) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                try {\n                  this._reconnectingCallbacks.forEach(function (c) {\n                    return c.apply(_this8, [error]);\n                  });\n                } catch (e) {\n                  this._logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\".concat(error, \"' threw error '\").concat(e, \"'.\"));\n                } // Exit early if an onreconnecting callback called connection.stop().\n\n\n                if (!(this._connectionState !== HubConnectionState.Reconnecting)) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n\n                return _context5.abrupt(\"return\");\n\n              case 15:\n                if (!(nextRetryDelay !== null)) {\n                  _context5.next = 43;\n                  break;\n                }\n\n                this._logger.log(LogLevel.Information, \"Reconnect attempt number \".concat(previousReconnectAttempts, \" will start in \").concat(nextRetryDelay, \" ms.\"));\n\n                _context5.next = 19;\n                return new Promise(function (resolve) {\n                  _this8._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n                });\n\n              case 19:\n                this._reconnectDelayHandle = undefined;\n\n                if (!(this._connectionState !== HubConnectionState.Reconnecting)) {\n                  _context5.next = 23;\n                  break;\n                }\n\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n\n                return _context5.abrupt(\"return\");\n\n              case 23:\n                _context5.prev = 23;\n                _context5.next = 26;\n                return this._startInternal();\n\n              case 26:\n                this._connectionState = HubConnectionState.Connected;\n\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\n\n                if (this._reconnectedCallbacks.length !== 0) {\n                  try {\n                    this._reconnectedCallbacks.forEach(function (c) {\n                      return c.apply(_this8, [_this8.connection.connectionId]);\n                    });\n                  } catch (e) {\n                    this._logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\".concat(this.connection.connectionId, \"; threw error '\").concat(e, \"'.\"));\n                  }\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 32:\n                _context5.prev = 32;\n                _context5.t0 = _context5[\"catch\"](23);\n\n                this._logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\".concat(_context5.t0, \"'.\"));\n\n                if (!(this._connectionState !== HubConnectionState.Reconnecting)) {\n                  _context5.next = 39;\n                  break;\n                }\n\n                this._logger.log(LogLevel.Debug, \"Connection moved to the '\".concat(this._connectionState, \"' from the reconnecting state during reconnect attempt. Done reconnecting.\")); // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\n\n\n                if (this._connectionState === HubConnectionState.Disconnecting) {\n                  this._completeClose();\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 39:\n                retryError = _context5.t0 instanceof Error ? _context5.t0 : new Error(_context5.t0.toString());\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n\n              case 41:\n                _context5.next = 15;\n                break;\n\n              case 43:\n                this._logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \".concat(Date.now() - reconnectStartTime, \" ms and \").concat(previousReconnectAttempts, \" failed attempts. Connection disconnecting.\"));\n\n                this._completeClose();\n\n              case 45:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[23, 32]]);\n      }));\n\n      function _reconnect(_x) {\n        return _reconnect2.apply(this, arguments);\n      }\n\n      return _reconnect;\n    }()\n  }, {\n    key: \"_getNextRetryDelay\",\n    value: function _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\n      try {\n        return this._reconnectPolicy.nextRetryDelayInMilliseconds({\n          elapsedMilliseconds: elapsedMilliseconds,\n          previousRetryCount: previousRetryCount,\n          retryReason: retryReason\n        });\n      } catch (e) {\n        this._logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\".concat(previousRetryCount, \", \").concat(elapsedMilliseconds, \") threw error '\").concat(e, \"'.\"));\n\n        return null;\n      }\n    }\n  }, {\n    key: \"_cancelCallbacksWithError\",\n    value: function _cancelCallbacksWithError(error) {\n      var _this9 = this;\n\n      var callbacks = this._callbacks;\n      this._callbacks = {};\n      Object.keys(callbacks).forEach(function (key) {\n        var callback = callbacks[key];\n\n        try {\n          callback(null, error);\n        } catch (e) {\n          _this9._logger.log(LogLevel.Error, \"Stream 'error' callback called with '\".concat(error, \"' threw error: \").concat(getErrorString(e)));\n        }\n      });\n    }\n  }, {\n    key: \"_cleanupPingTimer\",\n    value: function _cleanupPingTimer() {\n      if (this._pingServerHandle) {\n        clearTimeout(this._pingServerHandle);\n        this._pingServerHandle = undefined;\n      }\n    }\n  }, {\n    key: \"_cleanupTimeout\",\n    value: function _cleanupTimeout() {\n      if (this._timeoutHandle) {\n        clearTimeout(this._timeoutHandle);\n      }\n    }\n  }, {\n    key: \"_createInvocation\",\n    value: function _createInvocation(methodName, args, nonblocking, streamIds) {\n      if (nonblocking) {\n        if (streamIds.length !== 0) {\n          return {\n            arguments: args,\n            streamIds: streamIds,\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        } else {\n          return {\n            arguments: args,\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        }\n      } else {\n        var invocationId = this._invocationId;\n        this._invocationId++;\n\n        if (streamIds.length !== 0) {\n          return {\n            arguments: args,\n            invocationId: invocationId.toString(),\n            streamIds: streamIds,\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        } else {\n          return {\n            arguments: args,\n            invocationId: invocationId.toString(),\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        }\n      }\n    }\n  }, {\n    key: \"_launchStreams\",\n    value: function _launchStreams(streams, promiseQueue) {\n      var _this10 = this;\n\n      if (streams.length === 0) {\n        return;\n      } // Synchronize stream data so they arrive in-order on the server\n\n\n      if (!promiseQueue) {\n        promiseQueue = Promise.resolve();\n      } // We want to iterate over the keys, since the keys are the stream ids\n      // eslint-disable-next-line guard-for-in\n\n\n      var _loop = function _loop(streamId) {\n        streams[streamId].subscribe({\n          complete: function complete() {\n            promiseQueue = promiseQueue.then(function () {\n              return _this10._sendWithProtocol(_this10._createCompletionMessage(streamId));\n            });\n          },\n          error: function error(err) {\n            var message;\n\n            if (err instanceof Error) {\n              message = err.message;\n            } else if (err && err.toString) {\n              message = err.toString();\n            } else {\n              message = \"Unknown error\";\n            }\n\n            promiseQueue = promiseQueue.then(function () {\n              return _this10._sendWithProtocol(_this10._createCompletionMessage(streamId, message));\n            });\n          },\n          next: function next(item) {\n            promiseQueue = promiseQueue.then(function () {\n              return _this10._sendWithProtocol(_this10._createStreamItemMessage(streamId, item));\n            });\n          }\n        });\n      };\n\n      for (var streamId in streams) {\n        _loop(streamId);\n      }\n    }\n  }, {\n    key: \"_replaceStreamingParams\",\n    value: function _replaceStreamingParams(args) {\n      var streams = [];\n      var streamIds = [];\n\n      for (var i = 0; i < args.length; i++) {\n        var argument = args[i];\n\n        if (this._isObservable(argument)) {\n          var streamId = this._invocationId;\n          this._invocationId++; // Store the stream for later use\n\n          streams[streamId] = argument;\n          streamIds.push(streamId.toString()); // remove stream from args\n\n          args.splice(i, 1);\n        }\n      }\n\n      return [streams, streamIds];\n    }\n  }, {\n    key: \"_isObservable\",\n    value: function _isObservable(arg) {\n      // This allows other stream implementations to just work (like rxjs)\n      return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n    }\n  }, {\n    key: \"_createStreamInvocation\",\n    value: function _createStreamInvocation(methodName, args, streamIds) {\n      var invocationId = this._invocationId;\n      this._invocationId++;\n\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.StreamInvocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: MessageType.StreamInvocation\n        };\n      }\n    }\n  }, {\n    key: \"_createCancelInvocation\",\n    value: function _createCancelInvocation(id) {\n      return {\n        invocationId: id,\n        type: MessageType.CancelInvocation\n      };\n    }\n  }, {\n    key: \"_createStreamItemMessage\",\n    value: function _createStreamItemMessage(id, item) {\n      return {\n        invocationId: id,\n        item: item,\n        type: MessageType.StreamItem\n      };\n    }\n  }, {\n    key: \"_createCompletionMessage\",\n    value: function _createCompletionMessage(id, error, result) {\n      if (error) {\n        return {\n          error: error,\n          invocationId: id,\n          type: MessageType.Completion\n        };\n      }\n\n      return {\n        invocationId: id,\n        result: result,\n        type: MessageType.Completion\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(connection, logger, protocol, reconnectPolicy) {\n      return new HubConnection(connection, logger, protocol, reconnectPolicy);\n    }\n  }]);\n\n  return HubConnection;\n}(); //# sourceMappingURL=HubConnection.js.map","map":null,"metadata":{},"sourceType":"module"}